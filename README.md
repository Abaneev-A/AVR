# Содержание
+ [Настройка 8/16 битного таймера/счетчика](#Timer)

+ [Настройка ШИМ сигнала на пине](#PWM)

+ [Настройка интерфейса USART](#USART)


## <a name="Timer"></a>	**Настройка 8/16 битного таймера/счетчика**

### 1. ***Инициализация***

    TCCR0B = 1 << CS01; //установка предделителя
    TCNT0 = 56; //начало отчета

Формула расчета частоты счетчика:

f = F/ N * (TCNTmax - TCNT0) , где

N - предделитель

F - частота кварца

### 2. ***Прерывания***
#### 1. *Прерывание по переполнению*

Активация прерывания по переполнению:

    TIMSK0 = 1 << TOIE0;

Обработчик прерывания по переполнению:

    ISR(TIMER0_OVF_vect)
    {
         Код;
         TCNT0 = 56;
    }



## <a name="PWM"></a>	**Настройка ШИМ сигнала на пине**

### 1. ***Инициализация***

    DDRD = 1 << DDD6; // установка порта на выход
    TCCR0A = 1 << WGM00 | 1 << WGM01 | 1 <<  COM0A1; // установка Fast PWM и выхода ШИМ на пин OC0A
    TCCR0B = 1 << CS00 | 1 << CS02; // установка предделителя


### 2. ***Использование***

Изменяем скважность ШИМ путем записывания в регистр OCR0A значений от 0 до 256:

    OCR0A = 0...256;

## <a name="USART"></a>	**Настройка интерфейса USART**

## **Передача 1 байта**

### 1. ***Инициализация***

    UCSR0A = 1 << U2X0; // включаем удвоение скорости
    UBRR0L = 16; // задаем скорость работы USART
    UCSR0B = 1 <<  TXEN0; // Включаем передечу


Функция отправки данных:

    void USART_Transmit( unsigned char data )
    {
	while( !(UCSR0A & (1<<UDRE0)) ); //Ожидание опустошения буфера приема
	UDR0 = data; //Начало передачи данных
    }

## **Передача массива данных**

### 1. ***Инициализация***

    UCSR0A = 1 << U2X0; // включаем удвоение скорости
    UBRR0L = 16; // задаем скорость работы USART
    UCSR0B = 1 <<  TXEN0; // Включаем передечу


Функция отправки данных:

    void USART_Trans(unsigned char data[], const int size)
    {
	    for (int i = 0; i < size; i++)
	    {
		while (!(UCSR0A & (1 << UDRE0)));
		UDR0 = data[i];
	    }
    }


## **Прием и передача массива данных**

### 1. ***Инициализация***

    UCSR0A = 1 << U2X0; // включаем удвоение скорости
    UBRR0L = 16; // задаем скорость работы USART
    UCSR0B = 1 <<  RXEN0 | 1 <<  TXEN0 | 1 << RXCIE0; // Включаем прием и передечу, разрешаем прерывание по приему

    TCCR0B = 1 << CS01 | 1 << CS00; //установка предделителя
	TCNT0 = 56; //начало отчета

### 2. ***Прерывания***

Обработчик прерывания по приему:

    ISR(USART_RX_vect)
    {
	TIFR0 = 0x01;
	array[counter] = UDR0; // запись данных в массив из буфера
	counter++;
	TCNT0 = 56;
	if ((TIMSK0 & (1 << TOIE0)) == 0) TIMSK0 = 1 << TOIE0; // активация прерывания по переполнению
	if (counter == 100) counter = 0;
    }

Обработчик прерывания по переполнению:

    ISR(TIMER0_OVF_vect)
    {
        UCSR0B &= ~(1 << RXCIE0); // запрещаем прием по USART
        TIMSK0 &= ~(1 << TOIE0); // запрещаем прерывания по переполнению
        USART_Trans(uint8_t data[], uint16_t size); // отправляем данные по USART

        UCSR0B |= 1 << RXCIE0; // разрешаем прием по USART
    
        counter = 0; // сбрасываем счетчик
         TCNT0 = 56;
    }

Функция отправки данных:

    void USART_Trans(unsigned char data[], const int size)
    {
	    for (int i = 0; i < size; i++)
	    {
		while (!(UCSR0A & (1 << UDRE0)));
		UDR0 = data[i];
	    }
    }